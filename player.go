package helloworld

import (
	"encoding/json"
	"fmt"
	"log"
	"net/http"
)

// General method to send HTTP request given a method and URL
func (u *User) sendRequest(method string, reqURL string) bool {
	req, reqErr := http.NewRequest(method, reqURL, nil)
	if reqErr != nil {
		// fmt.Println("ReqErr:", reqErr)
		return false
	}

	exErr := u.execute(req, nil, http.StatusNoContent)
	if exErr != nil {
		// fmt.Printf("ExErr for %s:%s\n", reqURL, exErr)
		return false
	}

	return true
}

// Send Get HTTP Request given a URL and parameters
func (u *User) sendGetRequest(reqURL string, i interface{}) bool {
	exErr := u.get(reqURL, &i)
	if exErr != nil {
		fmt.Printf("ExErr for %s: %s\n", reqURL, exErr)
		return false
	}

	return true
}

// Pause playback for a User
func (u *User) Pause() bool {
	isPlaying, ok := u.IsPlaying()
	if !isPlaying {
		return true
	}

	reqURL := u.baseURL + "me/player/pause"
	ok = u.sendRequest(http.MethodPut, reqURL) && ok

	return ok
}

// Continue playback for a User (i.e. press play)
func (u *User) Play() bool {
	isPlaying, ok := u.IsPlaying()
	if isPlaying {
		return true
	}

	reqURL := u.baseURL + "me/player/play"
	ok = u.sendRequest(http.MethodPut, reqURL) && ok

	return ok
}

// Set User's Spotify volume
// vol = the volume to set (should be a value from 0 to 100 inclusive)
func (u *User) SetVolume(vol int) bool {
	if vol > 100 {
		vol = 100
	} else if vol < 0 {
		vol = 0
	}

	reqURL := u.baseURL + "me/player/volume?volume_percent=" + fmt.Sprint(vol)

	ok := u.sendRequest(http.MethodPut, reqURL)
	return ok
}

// Set User's repeat mode
// On boolean determines if repeat mode should be on or off
// Track boolean repeats track if true, repeats context (album, playlist, etc) if false
func (u *User) SetRepeat(on bool, track bool) bool {
	state := ""
	if !on {
		state = "off"
	} else if track {
		state = "track"
	} else {
		state = "context"
	}

	reqURL := u.baseURL + "me/player/repeat?state=" + state

	ok := u.sendRequest(http.MethodPut, reqURL)
	return ok
}

// Set shuffle mode for User
func (u *User) SetShuffle(on bool) bool {
	state := ""
	if on {
		state = "true"
	} else {
		state = "false"
	}

	reqURL := u.baseURL + "me/player/shuffle?state=" + state

	ok := u.sendRequest(http.MethodPut, reqURL)
	return ok
}

// Skip forward 1 track
func (u *User) SkipToNext() bool {
	reqURL := u.baseURL + "me/player/next"

	ok := u.sendRequest(http.MethodPost, reqURL)
	return ok
}

// Skip backwards 1 track
func (u *User) SkipToPrev() bool {
	reqURL := u.baseURL + "me/player/previous"

	ok := u.sendRequest(http.MethodPost, reqURL)
	return ok
}

// Add track to User's Queue
func (u *User) AddTrackToQueue(q Query, i interface{}) bool {
	uri := ""
	ok := true

	switch v := i.(type) {
	case string:
		bytes, searchErr := q.search(v, "track")
		if searchErr != nil {
			ok = false
		}

		searchResult := searchResult{}
		jsonErr := json.Unmarshal(bytes, &searchResult)

		if jsonErr != nil {
			log.Fatal("JSON Error:", jsonErr)
		}

		if searchResult.Tracks.Total > 0 {
			track := searchResult.Tracks.Items[0]
			uri = track.ID
		}
	case Track:
		uri = v.ID
	// Invalid Type
	default:
		return false
	}

	reqURL := u.baseURL + "me/player/queue?uri=spotify:track:" + uri

	ok = u.sendRequest(http.MethodPost, reqURL) && ok
	return ok
}

// Move to specific position in a song (by seconds)
func (u *User) SeekToPosition(seconds float64) bool {
	ms := seconds * 1000

	reqURL := u.baseURL + "me/player/seek?position_ms=" + fmt.Sprint(ms)

	ok := u.sendRequest(http.MethodPut, reqURL)
	return ok
}

// Return User's currently playing track
func (u *User) GetCurrentlyPlayingTrack() (Track, bool) {
	reqURL := u.baseURL + "me/player/currently-playing"
	track := currentlyPlaying{}

	ok := u.sendGetRequest(reqURL, &track)

	return track.Track, ok
}

// Currently Playing struct- maps to Spotify JSON response format by tag `json: "var_name"`
// Struct generated by putting Spotify JSON data into JSON to Go struct generator at:
// https://mholt.github.io/json-to-go/
type currentlyPlaying struct {
	Timestamp int64 `json:"timestamp"`
	Context   struct {
		ExternalUrls struct {
			Spotify string `json:"spotify"`
		} `json:"external_urls"`
		Href string `json:"href"`
		Type string `json:"type"`
		URI  string `json:"uri"`
	} `json:"context"`
	ProgressMs           int    `json:"progress_ms"`
	Track                Track  `json:"item"`
	CurrentlyPlayingType string `json:"currently_playing_type"`
	Actions              struct {
		Disallows struct {
			Pausing      bool `json:"pausing"`
			SkippingPrev bool `json:"skipping_prev"`
		} `json:"disallows"`
	} `json:"actions"`
	IsPlaying bool `json:"is_playing"`
}

// Return User's playback state
func (u *User) getPlaybackState() (playbackState, bool) {

	reqURL := u.baseURL + "me/player/currently-playing"
	pb := playbackState{}

	ok := u.sendGetRequest(reqURL, &pb)

	return pb, ok
}

// Playback State struct- maps to Spotify JSON response format by tag `json: "var_name"`
// Struct generated by putting Spotify JSON data into JSON to Go struct generator at:
// https://mholt.github.io/json-to-go/
type playbackState struct {
	Device       Device `json:"device"`
	ShuffleState bool   `json:"shuffle_state"`
	RepeatState  string `json:"repeat_state"`
	Timestamp    int64  `json:"timestamp"`
	Context      struct {
		ExternalUrls struct {
			Spotify string `json:"spotify"`
		} `json:"external_urls"`
		Href string `json:"href"`
		Type string `json:"type"`
		URI  string `json:"uri"`
	} `json:"context"`
	ProgressMs           int    `json:"progress_ms"`
	Item                 Track  `json:"item"`
	CurrentlyPlayingType string `json:"currently_playing_type"`
	Actions              struct {
		Disallows struct {
			Pausing      bool `json:"pausing"`
			SkippingPrev bool `json:"skipping_prev"`
		} `json:"disallows"`
	} `json:"actions"`
	IsPlaying bool `json:"is_playing"`
}

// Return whether a user is in shuffle mode or not
func (u *User) IsShuffling() (bool, bool) {
	pb, ok := u.getPlaybackState()
	return pb.ShuffleState, ok
}

// Return whether a user has music playing or not
func (u *User) IsPlaying() (bool, bool) {
	pb, ok := u.getPlaybackState()
	return pb.IsPlaying, ok
}

// Return User's current location in their currently playing track in seconds
func (u *User) CurrentTrackProgress() (float64, bool) {
	pb, ok := u.getPlaybackState()
	return float64(pb.ProgressMs / 1000), ok
}

// Return User's active Device
func (u *User) ActiveDevice() (Device, bool) {
	pb, ok := u.getPlaybackState()
	return pb.Device, ok
}

// Return User's current repeat state
func (u *User) CurrentRepeatState() (string, bool) {
	pb, ok := u.getPlaybackState()
	return pb.RepeatState, ok
}
